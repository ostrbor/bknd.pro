<html lang="ru" xmlns="http://www.w3.org/1999/html">
<head>
    <title>Backend Podcast: 18. testing-фреймворк в Go</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/modern-normalize@2.0.0/modern-normalize.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link href="../../css/css.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <div id="other-platforms">
        <a href="https://feeds.acast.com/public/shows/64727c07e689970012fb1c23">RSS</a>
        <a href="https://t.me/bkndpro">Telegram</a>
        <a href="https://www.youtube.com/@ostrbor/videos">YouTube</a>
        <a href="https://podcasts.apple.com/us/podcast/backend-podcast/id1732130106">Apple</a>
        <a href="https://music.yandex.ru/album/28370806">Яндекс</a>
        <a href="https://open.spotify.com/show/6G9K0DrOH2wsEqDKbed01e?si=oQXKuI4tQKqgJj894-2p_A">Spotify</a>
        <a href="https://music.amazon.com/podcasts/d797927c-7c90-4d4b-a845-3b61dc25060c/backend-podcast">Amazon</a>
        <a href="mailto:OstretsovAA+podcast@gmail.com">Почта</a>
    </div>
    <hgroup>
        <h1>18. testing-фреймворк в Go</h1>
        <h2>23.09.2023</h2>
    </hgroup>

    <p>
        <iframe src="https://embed.acast.com/64727c07e689970012fb1c23/650f1c4fafb89e001118602e?theme=light" frameBorder="0"
                width="100%" height="190px"></iframe>
        <a href="https://bknd.pro/podcast-files/018_backend_podcast.mp3">Скачать</a>
    </p>

    <p>
        <a href="../../index.html">К списку выпусков</a>
    </p>

    <h3>Основы testing пакета</h3>

    <p>
        Я люблю заглядывать в тесты, чтобы быстро понять, как работает код. Например, тесты в fmt-пакете объясняют
        работу ряда модификаторов нагляднее, чем документация.
    </p>

    <p>
        Также я обращаю внимание на пакет <code>*_test.go</code> файла. Если этот тот же пакет, что и тестируемый, то
        это модульное
        тестирование (есть доступ к неэкспортированные переменным). Если же это другой пакет, то часто это
        интеграционное
        тестирование, либо "black box" тестирование, т.е. такое, в котором проверяется работа нескольких функций/пакетов
        вместе.
    </p>

    <p>
        Также можно выполнение тестов пропускать, используя метод <code>Skip()</code>. Запуск тестов поддерживает
        переменную,
        позволяющую просигнализировать, что тесты должны быть короткими, для чего тесты следует запускать с флагом
        <code>-short</code>,
        а в тестах проверять значение этой переменной вызовом <code>testing.Short()</code>.
    </p>

    <h4>TestMain</h4>

    <p>
        Если нужно выполнить код, до и после выполнения тестов, то удобно использовать <code>TestMain</code> функцию:
    </p>

    <pre>
func TestMain(m *testing.M) {
    // setup
    os.Exit(m.Run())
    // teardown
}
</pre>

    <p>
        Организацию по типу табличных тестов можно сделать и с использованием суб-тестов <code>t.Run()</code>.
    </p>

    <h4>Примеры (Examples)</h4>

    <p>
        Удобны для демонстрации вашей идеи. Из полезного стоит отметить, что Examples-функции можно публиковать в Go
        playground'е (как и обычные тесты, но не бенчмарки), чтобы продемонстрировать работу вашего кода и сбросить
        например
        коллеге в чат ссылку на него.
    </p>

    <h4>Использование t.Error(), t.Errorf(), t.Fatal(), t.Fatalf() и т. д.</h4>

    <p>
        Прервать выполнение теста можно с помощью t.Fatal(f) и t.Error(f). Лучше использовать t.Error(f), чтобы выявить
        за
        один тест как можно больше ошибок и только если дальнеший тест невозможен из-за текущего состояния системы, то
        использовать t.Fatal(f).
    </p>

    <h4>Бенчмаркинг с testing пакетом и для чего это нужно?</h4>

    <p>
        По-умолчанию бэнчмарки не запускаются при выполнении <code>go test</code>. Нужно явно указать флаг
        <code>-bench</code>.
        Причем, если не указать название бенчмарка, то будут запущены все бенчмарки в пакете. Выполняются они
        последовательно.
    </p>

    <p>
        Бенчмарк по итогу работы выводит на экран скорость выполнения тестируемого кода и сколько было мемори-аллокаций
        (дополнительный флаг <code>-benchmem</code>).
    </p>

    <h4>Анализ результатов бенчмаркинга.</h4>

    <p>
        Т.к. бенчмарки на разных машинах дают разные результаты, то ценен именно сравнительный анализ (бенчмарки не
        нужно
        использовать для проверки скорости работы кода, для этого лучше подойдет QA-тестирование) тестируемого кода,
        выполняемый на одной машине. Т.е. тестируем старую версию кода и новую и сравниваем результаты. Для удобного
        сравнения двух результатов можно использовать утилиту benchstat. Она показывает процентное изменение
        результатов.
    </p>

    <h4>Фаззи-тестирование</h4>

    <p>
        Появилось в Go 1.18.
    </p>

    <p>
        Часто используется для тестирования парсеров и энкодеров/декодеров. Применяется для тестирования быстрого
        простого
        кода без разделяемого стейта (shared state).
    </p>

    <p>
        В основе фаззи-тестов сравнение стак-трейсов. Генерируются значения, сравниваются отклонения от предыдущих
        стак-трейсов. Фаззи-тест никогда не может быть пройден, если самостоятельно его не ограничить.
    </p>

    <p>
        Документация: <a href="https://go.dev/security/fuzz/">https://go.dev/security/fuzz/</a>
    </p>

    <p>
        Подробный туториал: <a href="https://go.dev/doc/tutorial/fuzz">https://go.dev/doc/tutorial/fuzz</a>
    </p>

    <h4>Где хранится кеш данных?</h4>

    <p>
        Механизм кеширования, введенный в Go 1.10, сильно ускорил выполнение тестов, исходный код которых не был
        изменен.
    </p>

    <p>
        Вы точно обратили внимание как быстро выполняются тесты, особенно, если это второй и последующие запуски. Дело в
        том, что билды и результаты выполнения тестов кешируются в директории <code>$GOCACHE</code> или в домашней
        директории пользователя <code>$HOME/.cache/go-build</code>.
    </p>

    <p>
        При выполнении тестов, если исходный код не изменялся, то тесты выполняются на основе кеша, о чем сообщается
        коментарием <code>(cached)</code> в консоли рядом с тестом.
    </p>

    <p>
        Очистка кеша возможно командой <code>go clean -cache</code>.
    </p>

    <h4>fstest</h4>

    <p>
        Добавлено в Go 1.16 для мока файловой системы в тестах.
    </p>

    <p>
        Часто приходится работать с файловой системой в коде. В этом случае в качестве зависимости лучше указать
        'io/fs.FS'
        (интерфейс с единственным методом <code>Open()</code>, возвращает файл и ошибку).
    </p>

    <p>
        Хорошая демонстрация использования: <a
            href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/reading-files">https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/reading-files</a>
    </p>

    <p>
        Также здесь же есть удобная хелпер-функции <code>TestFS(fsys fs.FS, expected ...string)</code> для проверки
        наличия
        файлов в указанной файловой системе
    </p>

    <h4>iotest</h4>

    <p>
        Если в вашем коде есть функции/методы, которые принимаю <code>Reader` или `Writer</code> интерфейсы, то вы
        можете
        протестировать их с помощью <code>iotest` пакета. Он содержит реализации `Reader` и `Writer</code> интерфейсов,
        для
        некоторых корнер-кейсов: <code>ErrReader`, `HalfReader`, `OneByteReader`, `TimeoutReader</code> и т.д.
    </p>

    <h4>Параллельное тестирование</h4>

    <p>
        <code>go test -p 1</code> - запускает тесты последовательно, тестируется один пакет за раз. В противном случае
        запускаются
    </p>

    <p>
        Вызов <code>t.Parallel()</code> сигнализирует testing-фреймворку, что тест можно запускать конкурентно с другими
        тестами, в
        которых есть вызов этой же функции. Если же возникли проблемы с конкурентным выполнением тестов, то можно
        использовать флаг <code>-parallel N</code> для ограничения количества параллельно выполняющихся рутин.
    </p>

    <p>
        Суб-тесты выполняются последовательно, поэтому если нужно их запустить параллельно, то нужно делать вызов
        <code>t.Parallel()</code> в каждом из них.
    </p>

    <h4>Покрытие кода</h4>

    <p>
        Покрытие кода тестами проверить очень легко - просто добавить флаг <code>-cover` при запуске `go test</code>. Мы
        увидим
        проценты покрытия по каждому протестированному пакету.
    </p>

    <p>
        Можно пойти дальше, сформировать профайл покрытия кода тестами: <code>go test -coverprofile=coverage.out
        ./...</code> (на
        выходе простой файл с перечислением позиций в коде, покрытых тестом или нет) и после этого визуализировать его с
        помощью утилиты <code>go tool cover -html=coverage.out</code>.
    </p>

    <p>
        Покрытие кода в первую очередь используем для идентификации непротестированных областей.
    </p>

    <p>
        Если у вас большая команда, то часто покрытие кода тестами включают в CI-цикл.
    </p>

    <p>
        <a href="../../index.html">К списку выпусков</a>
    </p>
    <div id="footer">
        By <a href="https://bknd.pro">bknd.pro</a>
    </div>
</div>
</body>
</html>