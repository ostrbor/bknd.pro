<html lang="ru" xmlns="http://www.w3.org/1999/html">
<head>
    <title>Backend Podcast: 16. Брокеры сообщений и очереди</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/modern-normalize@2.0.0/modern-normalize.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link href="../../css/css.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <div id="other-platforms">
        <a href="https://feeds.acast.com/public/shows/64727c07e689970012fb1c23">RSS</a>
        <a href="https://t.me/bkndpro">Telegram</a>
        <a href="https://www.youtube.com/@ostrbor/videos">YouTube</a>
        <a href="https://podcasts.apple.com/us/podcast/backend-podcast/id1732130106">Apple</a>
        <a href="https://music.yandex.ru/album/28370806">Яндекс</a>
        <a href="https://open.spotify.com/show/6G9K0DrOH2wsEqDKbed01e?si=oQXKuI4tQKqgJj894-2p_A">Spotify</a>
        <a href="https://podcasts.google.com/feed/aHR0cHM6Ly9mZWVkcy5hY2FzdC5jb20vcHVibGljL3Nob3dzLzY0NzI3YzA3ZTY4OTk3MDAxMmZiMWMyMw">Google</a>
        <a href="https://music.amazon.com/podcasts/d797927c-7c90-4d4b-a845-3b61dc25060c/backend-podcast">Amazon</a>
        <a href="mailto:OstretsovAA+podcast@gmail.com">Почта</a>
    </div>
    <hgroup>
        <h1>16. Брокеры сообщений и очереди</h1>
        <h2>09.09.2023</h2>
    </hgroup>

    <p>
        <iframe src="https://embed.acast.com/64727c07e689970012fb1c23/64fca42f1bcf47001159f61b?theme=light" frameBorder="0"
                width="100%" height="190px"></iframe>
        <a href="https://bknd.pro/podcast-files/016_backend_podcast.mp3">Скачать</a>
    </p>

    <p>
        <a href="../../index.html">К списку выпусков</a>
    </p>

    <h4>Почему и как я использовал брокеры сообщений в своих проектах?</h4>
    <p>
        Я использовал RabbitMQ для доставки E-mail и slack-нотификаций.
        С опытом пришло понимание, что в старых системах я также мог не использовать брокер сообщений.
        Например, доставка почты могла выполняться обычным batch processing'ом.
    </p>

    <p>
        Я использовал по большей части очереди из-за ограничений PHP, в котором нетривиально
        запустить ту же отправку письма асинхронно, но даже это на самом деле не нужно было в
        моем случае, т.к. отправка письма происходила через postfix, установленный на том же сервере.
        У postfix'а уже есть встроенная очередь сообщений на доставку.
    </p>

    <p>
        Брокеры сообщений и очереди - разные решения.
        Брокер сообщений часто представляет собой надстройку над очередями или их разновидностями.
    </p>

    <h4>Что такое очередь?</h4>
    <blockquote>
        Очередь (англ. queue) — это структура данных, добавление и удаление элементов в которой происходит
        путём операций и соответственно. Притом первым из очереди удаляется элемент, который был помещен
        туда первым, то есть в очереди реализуется принцип «первым вошел — первым вышел»
        (англ. first-in, first-out — FIFO).
    </blockquote>

    <p>
        Говоря о разработке ПО, сама по себе очередь - это уже усложнение.
        Если предполагается гарантировать клиенту очередность доставки, то это уже усложнение.
        Желательно настаивать на возможности задвоения событий и отсутсвии гарантий об очередности доставки.
    </p>

    <h4>Что такое брокер сообщений?</h4>

    <blockquote>
        Брокер сообщений — это программное обеспечение или служба, которая обеспечивает
        обмен сообщениями между различными системами, приложениями или компонентами.
        Он используется для облегчения асинхронного обмена сообщениями и может поддерживать
        различные модели обмена сообщениями, такие как очереди, топики, паблиш-сабскрайб (pub/sub) и другие.
    </blockquote>

    <p>
        Типы гарантий доставки сообщений:
    <ul>
        <li>
            <strong>at most once</strong>: простая (как UDP или как события в среде, где более
            важно актуальное событие, например видео игры);
        </li>
        <li>
            <strong>at least once</strong>: сложнее, но все еще просто (можно до определенной
            степени сравнить с TCP пакетом, где в силу проблем в сети, ПО и т.д.
            могут случиться задвоения пакетов, хотя и есть механизм дедупликации);
        </li>
        <li>
            <strong>exactly once</strong>: самый сложный особенно, если доставка
            сообщений очереди происходит через сетевую среду.
        </li>
    </ul>
    </p>

    <h4>RabbitMQ</h4>

    <blockquote>
        Messaging enables software applications to <strong>connect</strong> and <strong>scale</strong>. Applications can
        connect to
        each other, as components of a larger application, or to user devices and data. Messaging
        is asynchronous, decoupling applications by separating sending and receiving data.
    </blockquote>


    <p>
        <strong>Connect</strong>. Использование брокера сообщений в качестве транспорта.<br/>
        <strong>Scale</strong>. Легко можно масштабировать и реализовать механизм, например, fan-out, когда одно
        сообщение черед настроенный обменник (exchange) попадает сразу в несколько очередей. Оменники можно также
        комбинировать достигая дополнительного уровня масштабирования.
    </p>

    <h4>Когда использовать брокеры сообщений?</h4>

    <p>
        Если я скажу, что такие примеры есть, то это будет очень сильным утверждением. Часто, бывает несколько возможных
        решений.
        Потенциальные причины в пользу брокера сообщений:
    <ul>
        <li>нужна моментальная отправка сообщений и старый добрый batch processing не решает задачи;</li>
        <li>повышения доступности: отдельные брокеры выполняют простейшую функцию и поэтому могут показать себя более
            стабильными, чем потребители сообщений;
        </li>
        <li>потребность легкого масштабирования через увеличение количества реплик потребителей сообщений, настройки
            сложных маршрутов доставки сообщений;
        </li>
        <li>общение между решениями, реализованными на разных технологиях.</li>
    </ul>
    Каждый из этих пунктов в отдельности не является гарантией почему нужно использовать брокеры сообщений. Желательно
    принимать решение по совокупности указанных выше причин.
    </p>

    <p>
        Проблемы связанные с брокерами сообщений
    <ul>
        <li>расширение стека:
            <ul>
                <li>
                    мониторинг, алертинг не только основной системы, но и брокера сообщений);
                </li>
                <li>
                    мониторинг работы косьюмеров;
                </li>
                <li>
                    повышается сложность функционального тестирования (готовую систему с брокером сообщений
                    захочется проверить всю и для этого развернуть максимально близкий к production-среде стек).
                </li>
            </ul>
        </li>
        <li>
            отсутсвие атомарности отправки сообщения
            (можно использовать паттерн
            <a href="https://microservices.io/patterns/data/transactional-outbox.html">Transactional Outbox</a>);
        </li>
        <li>
            дополнительная сложность управления сообщениями в очереди:
            <ul>
                <li>повторная передача сообщения в очередь;</li>
                <li>повторная доставка сообщений;</li>
                <li>
                    обеспечение очередности, - если действительно стоит такая задача - в конкурентной среде
                    (если, предположим, HTTP запросы к сервису пришли последовательно, то из-за конкурентного
                    выполнения кода прозведенные ими сообщения, в очередь могут быть записаны в обратном порядке);
                </li>
                <li>
                    где хранить недоставленные сообщения, где хранить причину недоставки
                    (или отказа обработки) сообщения, т.е. нужно персистентное хранилище.
                </li>
            </ul>
        </li>
    </ul>
    </p>

    <h4>Выводы</h4>
    <p>
    <ul>
        <li>
            используем batch processing до тех пор, пока это возможно, избегаем предварительной оптимизации
            (возможно клиенту не так важно получать сообщения максимально оперативно);
        </li>
        <li>
            синхронные решения проще в реализации асинхронных;
            если есть брокер сообщений, то может его стоит заменить на синхронные вызовы и отказаться от брокера?
        </li>
        <li>
            используем простые маханизмы на базе транзакционной БД (если она в центре приложения),
            например, использовать транзакционный LISTEN/NOTIFY в PostgreSQL.
        </li>
        <li>
            если используем брокер сообщений, то для упрощения отказываемся от гарантированного порядка
            доставки сообщений и избегаем exactly once гарантий доставки.
        </li>
    </ul>

    Заключение с цитатой из книги Designing Data Intensive Applications (последняя глава, Stream Processing):

    <blockquote>
        A complex system that works is invariably found to have evolved from a simple system that works.
        The inverse proposition also appears to be true: A complex system designed from scratch never works
        and cannot be made to work. —John Gall, Systemantics (1975)
    </blockquote>
    </p>

    <p>
        <a href="../../index.html">К списку выпусков</a>
    </p>
</div>
</body>
</html>