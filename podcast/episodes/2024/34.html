<html lang="ru" xmlns="http://www.w3.org/1999/html">
<head>
    <title>Backend Podcast: 34. Выстрел в ногу с PostgreSQL</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/modern-normalize@2.0.0/modern-normalize.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link href="../../css/css.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <div id="other-platforms">
        <a href="https://feeds.acast.com/public/shows/64727c07e689970012fb1c23">RSS</a>
        <a href="https://t.me/bkndpro">Telegram</a>
        <a href="https://www.youtube.com/@ostrbor/videos">YouTube</a>
        <a href="https://podcasts.apple.com/us/podcast/backend-podcast/id1732130106">Apple</a>
        <a href="https://music.yandex.ru/album/28370806">Яндекс</a>
        <a href="https://open.spotify.com/show/6G9K0DrOH2wsEqDKbed01e?si=oQXKuI4tQKqgJj894-2p_A">Spotify</a>
        <a href="https://music.amazon.com/podcasts/d797927c-7c90-4d4b-a845-3b61dc25060c/backend-podcast">Amazon</a>
        <a href="mailto:OstretsovAA+podcast@gmail.com">Почта</a>
    </div>

    <hgroup>
        <h1>34. Выстрел в ногу с PostgreSQL</h1>
        <h2>14.01.2024</h2>
    </hgroup>

    <p>
        <iframe src="https://embed.acast.com/64727c07e689970012fb1c23/65a445b1c181320016ad050d?theme=light" frameBorder="0" width="100%" height="190px"></iframe>
        <a href="https://bknd.pro/podcast-files/034_backend_podcast.mp3">Скачать</a>
    </p>

    <p>
        <a href="../../index.html">К списку выпусков</a>
    </p>

    <h4>Ссылки выпуска:</h4>
    <ul>
        <li><a href="https://philbooth.me/blog/nine-ways-to-shoot-yourself-in-the-foot-with-postgresql">https://philbooth.me/blog/nine-ways-to-shoot-yourself-in-the-foot-with-postgresql</a></li>
        <li><a href="https://www.reddit.com/r/PostgreSQL/comments/12w574s/nine_ways_to_shoot_yourself_in_the_foot_with/">Обсуждение статьи Фила на reddit</a></li>
        <li><a href="https://www.youtube.com/watch?v=pJWCwfv983Q">Три типа JOIN'ов: https://www.youtube.com/watch?v=pJWCwfv983Q</a></li>
        <li><a href="https://github.com/tcdi/plrust">PL/Rust для PostgreSQL: https://github.com/tcdi/plrust</a> (997 stars)</li>
        <li><a href="https://github.com/citusdata/pg_cron">pg_cron: https://github.com/citusdata/pg_cron</a> (2.4 stars)</li>
        <li><a href="https://www.postgresql.eu/events/pgconfeu2022/sessions/session/3902/slides/354/CTEsAndTheirMaterialization-DivyaSharma.pdf">Слайды с доклада о производительности CTE</a> (AWS, 2022)</li>
    </ul>

    В этом выпуске мы обсудим <a href="https://philbooth.me/blog/nine-ways-to-shoot-yourself-in-the-foot-with-postgresql">статью</a> Фила Бута под названием:
    <h4>9 способов выстрелить себе в ногу с PostgreSQL</h4>

    <p>
        Попробуем аргументированно согласится или не согласится с автором.
    </p>

    <h4>1. Оставить значение <code>work_mem</code> по умолчанию.</h4>

    <p>
        <code>work_mem</code> - максимальный объем используемой памяти для выполнения запроса.
        Если мы делаем JOINы (hash/merge join), CTE или сортировки, то значение <code>work_mem</code> важно для эффективного выполнения запроса.
        Посмотреть текущее значение можно: <code>SHOW work_mem;</code>.
        Для текущей сессии можно задать значение таким образом: <code>SET [ SESSION | LOCAL ] work_mem TO '16MB';</code>.
        <code>SET SESSION</code> устанавливает значение параметра для текущей сессии, <code>LOCAL</code> для транзакции.
    </p>

    <p>
        Но как понять какое значение устнавливать для <code>work_mem</code>?
        Для этого нужно проверять вывод <code>EXPLAIN (ANALYSE, BUFFERS)</code>:
        если будет hash join, то вы увидите размер hash-таблицы для мержа (нужно искать "Memory usage").
        Так, опытным путем станет понятно достаточно ли дефолтных 4Мб или это значение нужно увеличить.
    </p>

    <p>
        Дефолтные 4Мб - это вполне достаточно для старта.
        Т.е. можно вполне запускаться в продакшн с этим дефолтом.
        Важно не упускать мониторинг за медленными запросами, в чем может помочь, например, pgBadger.
    </p>

    <h4>2. Перенести логику приложения в функции и хранимые процедуры.</h4>

    <p>
        На самом деле это вполне себе неплохая идея.
        Я даже работал с биллинг системой в телекоме, где на хранимых процедурах было построено чуть больше чем все.
        Также хранимые процедуры можно писать не только на динамических ЯП вроде Python 3, TCL, Perl, но и на, например,
        <a href="https://github.com/tcdi/plrust">Rust</a>.
    </p>

    <p>
        Преимущества: нет сетевых издержек. Недостаток: меньшая гибкость (в коде внести правки проще),
        проблемы с версионированием (если надо, чтобы работала как старая логика, так и новая).
    </p>

    <p>
        В этом вопросе я расхожусь с мнением автора.
        Хранимые процедуры - отличные инструмент, который может прийтись в пору на орпеделенном этапе развития проекта.
    </p>

    <h4>3. Очень много триггеров.</h4>

    <p>
        Начинаем с простых ограничений (constraints): CHECK, NOT NULL, UNIQUE, PK, FK, EXCLUDE.
        Если необходимо вставить калькулированные данные в колонку, то лучше рассмотреть возможность использования
        сгенерированных колонок (GENERATED COLUMNS) или, если нужно формировать больше данных, на основе существующих,
        то обратиться к материализованным представлениям (MATERIALIZED VIEWS).
        Кстати, обновлять данные материализованных представлений можно с помощью REFRESH и делать это в самом PostgreSQL
        с использованием расширения <a href="https://github.com/citusdata/pg_cron">pg_cron</a>.
        Если эти средства исчерпаны, а цель не достигнута, то можно рассмотреть триггеры.
        Например, если надо убедиться в целостности данных, когда речь идет о других таблицах.
    </p>

    <p>
        Триггеры не стоит рассматривать как модель событийно-ориентированной разработки.
        Например, не стоит логгировать в таблицу из триггеров, когда данные были добавлены в какую-то таблицу.
        Лучше предпочесть принцип "явное лучше неявного" и писать явно лог-таблицу в соседнем запросе.
    </p>

    <h4>4. Активное использование NOTIFY.</h4>

    <p>
        Если нужно немедленно сообщить об успешном завершении транзакции, то можно использовать <code>NOTIFY</code>.
        Это решение хорошо тем, что уведомления транзакционные.
        Все слушающие стороны принимают просто строку.
        Строку можно оформить в виде JSON-объекта, например, используя <code>row_to_json</code> функцию.
    </p>

    <p>
        Проблема с этим решением в том, что все равно нужно где-то хранить payload уведомления на случай,
        если по какой-либо причине не было ни одного активного слушателя (LISTEN).
        Я поступаю так: делаю очередь прямо тут, в PostgreSQL (если это позволяют требования) и в добавок,
        как элемент усложнения, добавляю NOTIFY.
    </p>

    <p>
        Для организации очереди создаем простую табличку, в которой по крону выбираем задачи.
        Не забываем, что выборка может случится конкурентная, поэтому полезно использовать в SELECT-запросе
        <code>FOR UPDATE SKIP LOCKED</code>.
    </p>

    <h4>5. Не использовать EXPLAIN ANALYZE.</h4>

    <p>
        Полностью согласен, что инструмент крайне полезный.
        Чем больше и сложнее проект, тем чаще нужно анализировать ваши запросы с помощью <code>EXPLAIN ANALYZE</code>.
        Там можно увидеть какие индексы используются, сколько потребляется памяти, как быстро выполняется запрос и т.д.
        Особенно полезно прибегать к EXPLAIN для анализа запросов к большим таблицам или при слиянии таблиц (JOIN).
    </p>

    <h4>6. Предпочитать CTE, а не подзапросы.</h4>

    <p>
        Чем хороши CTE? Читаемость, переиспользуемость (и рекурсии; с ними у меня очень мало опыта)!
        Особенно это удобно, когда у вас есть серия запросов, где один зависит от результатов предыдущего.
    </p>

    <p>
        Итак, до 12 версии PostgreSQL, все CTE были MATERIALIZED.
        Это значит, что результаты работы выражения сохранялись в оперативной памяти вроде как таблица,
        у которой естественно нет индексов и любые операции с этими данными означала <code>Seq Scan</code> в EXPLAIN.
        С 12 версии все запросы стали NOT MATERIALIZED.
        Т.е. если планировщик посчитает, что можно превратить CTE в подзапрос, то он это сделает.
    </p>

    <p>
        <code>work_mem</code> и тут о себе напоминает!
        Промежуточные результаты работы CTE хранятся как раз в этой памяти.
    </p>

    <p>
        Итого, можно вполне спокойно использовать CTE.
        Не забываем про п. 5 и проверяем эффективность выполнения запросов.
    </p>

    <h4>7. Использование рекурсивных CTE.</h4>

    <p>
        Все, что требует рекурсии в СУБД скорее всего может быть денормализовано так, чтобы рекурсия не была нужна.
        В случае древовидных структур есть nested set или полная денормализация графа.
        Да, во втором случае долгая запись, но зато очень быстрое чтение!
    </p>

    <h4>8. Не добавлять индексы к FK.</h4>

    <p>
        В MySQL индексы создаются автоматически для колонки, которая является FK. В PostgreSQL это не так.
        Без индексов каждый JOIN по FK становится ударом по ресурсам.
        Не забываем, что даже если мы не делаем JOIN по FK,
        но у нас есть каскадное удаление или обновление FK (ON DELETE, ON UPDATE) то индексы тоже нужны!
        Если не пренебрегать EXPLAIN, то вы точно не пропустите отсутствие индекса.
    </p>

    <h4>Заключение</h4>

    <p>
        От себя я еще добавлю, что имеет смысл <strong>периодически обновлять PostgreSQL</strong> до более свежих версий.
        Как и со всеми обновлениями торопиться не стоит.
        В новых версиях как правило улучшается производительность, улучшается планировщик и т.д.
    </p>

    <p>
        <a href="../../index.html">К списку выпусков</a>
    </p>
    <div id="footer">
        By <a href="https://bknd.pro">bknd.pro</a>
    </div>
</div>
</body>
</html>