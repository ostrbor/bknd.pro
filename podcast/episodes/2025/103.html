<html lang="ru" xmlns="http://www.w3.org/1999/html">
<head>
    <title>Backend Podcast: 103. PostgreSQL 18</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/modern-normalize@2.0.0/modern-normalize.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Roboto:wght@400;700&display=swap"
          rel="stylesheet">
    <link href="../../css/css.css?2024-08-04" rel="stylesheet">
</head>
<body>
<div class="container">
    <div id="other-platforms">
        <a href="https://feeds.acast.com/public/shows/64727c07e689970012fb1c23">RSS</a>
        <a href="https://t.me/bkndpro">Telegram</a>
        <a href="https://www.youtube.com/@ostrbor/videos">YouTube</a>
        <a href="https://podcasts.apple.com/us/podcast/backend-podcast/id1732130106">Apple</a>
        <a href="https://music.yandex.ru/album/28370806">Яндекс</a>
        <a href="https://open.spotify.com/show/6G9K0DrOH2wsEqDKbed01e?si=oQXKuI4tQKqgJj894-2p_A">Spotify</a>
        <a href="https://music.amazon.com/podcasts/d797927c-7c90-4d4b-a845-3b61dc25060c/backend-podcast">Amazon</a>
        <a href="mailto:OstretsovAA+podcast@gmail.com">Почта</a>
    </div>

    <hgroup>
        <h1>103. PostgreSQL 18</h1>
        <h2>25.05.2025</h2>
    </hgroup>

    <p>
        <iframe src="https://embed.acast.com/64727c07e689970012fb1c23/68332690e57506ea978868c4" frameBorder="0" width="100%" height="190px"></iframe>
        <a href="https://bknd.pro/podcast-files/103_backend_podcast.mp3">Скачать</a>
    </p>

    <p>
        <a href="../../index.html">К списку выпусков</a>
    </p>

    <h4>Ссылки выпуска:</h4>
    <ul>
        <li>
            <a href="https://www.postgresql.org/docs/18/release-18.html">
                Release 18
            </a>
        </li>
    </ul>

    <h4>Улучшения производительности</h4>

    <p>
        Улучшен планировщик. Так же как постоянно улучшается crypt пакет в Go, также регулярно обновляется и улучшается
        планировщик в PostgreSQL. На практике это обозначает, что даже если запрос выстроен неоптимально, то некоторые
        неоптимальности смогут быть преодолены на этапе планирования выполненеия запроса. Добавлено:
    </p>

    <ul>
        <li>удаление лишних JOIN'ов;</li>
        <li>ускорение SELECT DISTINCT за счет того, что в некоторых случаях необязательно делать сортировку.</li>
    </ul>

    <p>
        Добавлена поддержка <code>skip scan</code> составных индексов. Напомню что такое составной индекс. Представим
        заказ, у которого есть ID покупателя и дата. Если мы часто делаем запросы на выборку заказов для конкретного
        покупателя и датой больше определенного значения, например за последние 3 месяца, то можно добавить составной
        индекс, т.е. в индексе будет как ID покупателя, так и дата заказа. Фильтрация будет работать быстрее.
        Однако, если мы захотим выбрать заказы старше какой-то даты, например, за последние три месяца для <strong>всех</strong>
        клиентов, то индекс не будет использован. В PostgreSQL 18, благодаря skip scan, такой индекс всё же может быть
        использован, если клиентов не слишком много.
    </p>

    <p>
        Добавлена <strong>параллельное построение GIN-индекса</strong>. Построение GIN-индекса для одних и тех же данных
        всегда занимает больше времени, чем дефолтный BTree. Теперь GIN-индекс будет строится параллельно на нескольких
        ядрах.
    </p>

    <p>
        <strong>Улучшено отсеивание (pruning) партиций</strong> на этапе планирования. Когда используем партицирование (от слова part - часть)?
        Классический пример - таблица логов, когда для каждого месяца создаем отдельную партицию. До 18 версии PostgreSQL залезал
        во все партиции, читал их метаданные, провоцировал кратковременные блокировки. Благодаря улучшенному
        планировщику сейчас если ты сделаешь выборку по кокретному месяцу из таблицы логов, то будет обращение только
        к одной партиции, а остальные останутся нетронутыми. Это в целом ускоряет чтение данных из партицированной
        таблицы.
    </p>

    <p>
        Оптимизирован механизм блокировок, если делаешь аналитический запрос из десятков таблиц.
    </p>

    <p>
        <strong>Улучшен автовакум</strong>. Он теперь агресивнее замораживает строки. Что такое заморозка?
        В PostgreSQL есть механизм MVCC, про который мы делали выпуск. Каждая строка хранит диапазон видимости для
        транзакций с двумя значениями: xmin, xmax. Чтобы избежать постоянных сравнений по нижней границе xmin, ей
        назначают специальное значение, которое говорит, что значение очень старое и можно простым образом проверить
        видимость замороженной строчки. Чем больше замороженных данных, тем быстрее работают выборки в конкурентной
        среде. Оптимизация автовакуума в плане заморозки приведет к тому, что он будет агрессивнее морозить строки, а
        значит общая производительность СУБД в условиях конкурентной нагрузки вырастет.
    </p>

    <p>
        Также <strong>повысили некоторые дефолтные значения</strong> для того, чтобы PostgreSQL агрессивнее потребляла ресурсы.
        Дефолтные настройки PostgreSQL всегда отличались консервативностью и по крайней мере несколько из них нужно
        всегда настраивать на сколько нибудь свежем железе: тот же shared_buffers, work_mem, maintanance_work_mem и т.д.
    </p>

    <h4>Изменения в SQL</h4>

    <p>
        Генерируемый столбец (generated) - это колонка, значение которой вычисляется на основе данных других колонок.
        Например, стоимость товара с налогом или, например, надо перевернуть строку и проиндексировать,
        чтобы работало вхождение по окончанию через LIKE.
        Такие колонки stored по умолчанию до PostgreSQL 18. Сейчас они сделаны
        виртуальными по-умолчанию. Идея в том, чтобы сократить занимаемое место на дисках по-умолчанию.
    </p>

    <p>
        <strong>Улучшенный RUTURNING</strong>. Наконец-то можно с помощью специальных имен <code>old</code> и <code>new</code>
        указать какие данные я хочу получить в ответ на UPDATE. Раньше надо было исхитрятаться с CTE. Похожий функционал
        c old и new я встречал в триггерах MySQL и Oracle.
    </p>

    <p>
        Поддержка недетерминированных (детерминированный = ясный, конкретный) коллаций (механизм сравнения) в LIKE.
        Недетерминированная коллация может игнорировать регистр, акценты. Так, 'straße' = 'strasse' в немецкой
        недетерминированной коллации.
    </p>

    <p>
        Добавлен провайдер коллаций <code>PG_UNICODE_FAST</code> позволяющий сортировать не по сложным правилам
        естественных языков, а по кодпоинтам Unicode. Если тебе просто надо отсортировать быстро, например, для
        построения индекса, то можно быстрее сделать это используя коллацию по кодпоинтам Unicode.
    </p>

    <p>
        Добавлен <code>WITHOUT OVERLAPS</code> модификатор для последней колонки композитного первичного ключа.
        Т.е. без пересечений. Актуально, если используется тип <code>tstzrange</code> (диапазон дат). Например,
        приём у врача не может быть одновременно у двух пациентов в пересекающийся диапазон времени или дат.
        Теперь можно простым модификатором <code>WITHOUT OVERLAPS</code> добавить строгости.
    </p>

    <p>
        Функция <code>UUID_v7()</code> генерирует UUIDv7 с временной компонентой, которую можно использовать для
        хронологической сортировки.
    </p>

    <h4>Репликация</h4>

    <p>
        Есть два вида репликаций PostgreSQL - физическая и логическая. Обе работают на базе WAL (write ahead log), т.е.
        журнала предзаписи. В случае физической обновления WAL сразу транслируются реплике, а в случае логической
        транслируются команды изменения данных вроде INSERT, UPDATE. Формат таких логов содержит действие, целевую
        таблицу и данные (можно представить в JSON, есть для декодирования спец плагины). Логическая репликация
        позволяет выполнять репликацию, скажем только одной таблицы.
    </p>

    <p>
        <strong>Добавлено автоматическое отключение физической реплики</strong>. Если реплика падает, то части (слоты)
        WAL журнала накапливаются на мастер-сервере безгранично. Это могло привести к сбоям главного сервера. В 18
        версии данные WAL слоты накапливаются некоторое время, а потом дропаются. Реплику прийдется в этом случае
        пересоздавать заново.
    </p>

    <p>
        И ускорена сама реплика. Теперь сервер-подписчик может выполнять транзакции параллельно, а не последовательно
        как было раньше. Особенно это должно дать ускорение при первоначальной синхронизации большой базы.
    </p>

    <h4>Безопасность</h4>

    <p>
        <strong>md5 хеш для паролей теперь deprecated!</strong> Переходите на sha256. Судя по всему поддержка md5
        хеша пароля может быть отключена в следующих версиях.
    </p>

    <p>
        <strong>oAuth 2.0</strong> добавлена для аутентификации через Single Sign-On (от корпоративной системы или
        провайдера аутентификаций вроде Google/Github и т.д.). Для разработчика это обернется только тем, что нужно
        будет авторизовываться в СУБД по короткоживущему токену.
    </p>

    <p>
        <strong>Улучшено шифрование TLS 1.3</strong>. По умолчанию в набор групп шифрования добавлена современная
        эллиптическая кривая X25519, которая обеспечивает высокую скорость и стойкость шифрования.
    </p>

    <p>
        <strong>Контрольные суммы целостности данных</strong> включены теперь по-умолчанию. Такая контрольная сумма -
        это отпечаток, позволяющий проверить целостность страницы данных. Раньше эту опцию нужно было включать вручную.
        Чтобы активировать чексуммы на работающей системе её прийдется остановить и запустить специальную команду.
        Процесс обновления страниц памяти может занять много времени в зависимости от системы.
    </p>

    <h4>Разработка расширений</h4>

    <p>
        Расширения могут добавлять доп опции в EXPLAIN. Представим, что вы создали свой тип индекса или какой-то
        планировщик запросов: теперь можно реализовать кастомные параметры EXPLAIN, чтобы отображать специфичные
        детали вашего расширения при анализе запросов.
    </p>
</div>
</body>
</html>